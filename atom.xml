<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Machine Musicianship]]></title>
  <link href="http://ekozhura.github.io/atom.xml" rel="self"/>
  <link href="http://ekozhura.github.io/"/>
  <updated>2014-07-13T23:55:46+03:00</updated>
  <id>http://ekozhura.github.io/</id>
  <author>
    <name><![CDATA[Evgeny Kozhura]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Обзор Tidal]]></title>
    <link href="http://ekozhura.github.io/tidal"/>
    <updated>2014-07-13T23:29:35+03:00</updated>
    <id>http://ekozhura.github.io/tidal</id>
    <content type="html"><![CDATA[<p>Tidal &ndash; это микроязык для создания паттернов. Никаких юнит-генераторов, синтеза и dsp в Tidal нет, в качестве аудиодвижка используется внешняя библиотека Dirt. Dirt &ndash; это даже не синтезатор, а просто сэмплер. В комплекте с Dirt&#8217;ом идет набор перкуссионных сэмплов, при желании можно добавить своих семплов и использовать их с Tidal. На первый взгляд все очень просто и скромно, но тем не менее, открывает широкие возможности для экспериментов.</p>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F153640684&amp;"></iframe>


<!--more-->


<p>Tidal является &ldquo;встраиваемым&rdquo; языком, он не только написан на Haskell, но и выполняется в его окружении. При этом знание Haskell не обязательно, хотя Алекс Маклин (автор проекта) и рекомендует (ну мало ли, что он рекомендует). Использование интерпретатора позволяет создавать и модифицировать паттерны на лету. Таким обращом, Tidal изначально разрабатывался как язык для лайвкодинга.</p>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F114878404&amp;"></iframe>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">d1</span> <span class="o">$</span> <span class="p">(</span><span class="n">spread&#39;</span> <span class="p">(</span><span class="n">striate&#39;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">((</span><span class="o">+</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">$</span> <span class="o">&gt;</span> <span class="n">slow</span> <span class="mi">8</span> <span class="n">sine1</span><span class="p">))</span> <span class="o">$</span> <span class="n">jux</span> <span class="n">rev</span> <span class="o">$</span> <span class="n">sound</span> <span class="p">(</span><span class="n">samples</span> <span class="s">&quot;[latibro*6,bd]/2&quot;</span> <span class="s">&quot;0 7 4&quot;</span><span class="p">)</span> <span class="o">|+|</span> <span class="n">speed</span> <span class="s">&quot;[1 2 1.5]/4&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Код может быть как тривиальным:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">d1</span> <span class="o">$</span> <span class="n">sound</span> <span class="s">&quot;bd&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Так и достаточно сложным:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">d1</span> <span class="o">$</span> <span class="p">(</span><span class="n">slow</span> <span class="mi">16</span> <span class="o">$</span> <span class="n">trunc</span> <span class="mf">0.25</span> <span class="o">$</span> <span class="n">every</span> <span class="mi">3</span> <span class="p">(</span><span class="o">|+|</span> <span class="n">sound</span> <span class="s">&quot;tabla:4&quot;</span><span class="p">)</span> <span class="o">$</span> <span class="n">striate&#39;</span> <span class="mi">256</span> <span class="mf">0.2</span> <span class="o">$</span> <span class="n">sound</span> <span class="s">&quot;tabla:1&quot;</span><span class="p">)</span> <span class="o">|+|</span> <span class="n">speed</span> <span class="p">(</span><span class="n">every</span> <span class="mi">3</span> <span class="p">((</span><span class="o">*</span><span class="mf">1.8</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">$</span> <span class="p">((</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="s">&quot;[[1 0.5 0.75 1.25 1.1225 1.1225 1 1.5 2], [~ 0.5 ~]/4, [4 ~ ~ 4 ~ ~ 2 6 ~ 3 ~ 8]/5]&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">|+|</span> <span class="n">vowel</span> <span class="s">&quot;[a o u i e]/5&quot;</span>
</span><span class='line'><span class="o">|+|</span> <span class="n">gain</span> <span class="s">&quot;3&quot;</span>
</span><span class='line'><span class="o">|+|</span> <span class="n">delay</span> <span class="s">&quot;[0 0 0 [0.5 0]/2 0]/3&quot;</span>
</span><span class='line'><span class="o">|+|</span> <span class="n">delaytime</span> <span class="s">&quot;0.5&quot;</span>
</span><span class='line'><span class="o">|+|</span> <span class="n">delayfeedback</span> <span class="s">&quot;0.6&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F149775631&amp;"></iframe>


<p>В Tidal реализовано некоторое количество функций для генерации и преобразования паттернов, и также поощряется расширение пользовательскими функциями. Событийная модель отличается от SuperCollider и Common Music тем, что паттерны не являются последовательностью (или потоком) событий, а скорее функцией значения времени от события, что по мнению автора дает некоторые преимущества для лайв кодинга. Автор упоминал расширения, которые включают интеграцию с OSC протоколом.</p>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F129063081&amp;"></iframe>


<p>Порог входа в Tidal достаточно низкий &ndash; синтаксис простой и лаконичный, функций не так много.
Правда перед работой необходимо пройти нетриввиальный квест по установке (установи это, запусти то), и столкнутся с некоторыми ограничениями (только emacs, только хардкор). Помимо Dirt, для запуска Tidal требуется Jack. Я говорил, что в качестве редактора мы ограничены emacs?</p>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F127869914&amp;"></iframe>


<p>Лаконичный синтаксис Tidal подталкивает к разным инициативам вроде Tidal cycles (аналог SCTweets, твиты со снэпшотами) или 365 Tidal Patterns (челендж &ndash; один паттерн в день на протяжении года). Код сопровождается аудиопримерами, прослушал, скопировал, запустил. А дальше модифицируй, как тебе вздумается.</p>

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="http://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F127442915&amp;"></iframe>


<p>Информация о проекте: <a href="http://yaxu.org/">http://yaxu.org/</a></p>

<p>Github: <a href="https://github.com/yaxu/Tidal/">https://github.com/yaxu/Tidal/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Композиция в SuperCollider. Часть 1. Потоки]]></title>
    <link href="http://ekozhura.github.io/supercollider-score-language-part-1"/>
    <updated>2014-07-13T09:04:59+03:00</updated>
    <id>http://ekozhura.github.io/supercollider-score-language-part-1</id>
    <content type="html"><![CDATA[<p>Основой алгоритмической композиции, по сути, являются математические методы генерации партитур. Синтаксические конструкции или библиотеки функций и классов, которые используются в композиции, часто выделяются в так называемый score language, то есть язык, который используется для определения партитур. Score language в SuperCollider базируется на потоках (абстрактный класс Stream), событиях (класс Event) и  паттернах (абстрактный класс Pattern). Сперва рассмотрим потоки.</p>

<!--more-->


<p>Термины <strong>итератор</strong>, <strong>генератор</strong> и <strong>поток</strong> в разных языках программирования используются для описания похожих концепций и абстракций, но не всегда аналогичных. В общем случае, итератор &ndash; это объект, который осуществляет последовательный доступ к элементам коллекции. Это несколько отличается от перебора элементов коллекции по их индексам.</p>

<p>Интерфейс итератора предполагает следующее поведение. Во-первых, необходимо инициализировать итератор с каким-то начальным состоянием и сбрасывать состояние итератора на начальное. Начальное состояние чаще всего предполагает, что итератор вернет первый элемент коллекции. Во-вторых, необходимо извлекать следующий элемент коллекции. И наконец, если коллекция имеет конечное число элементов, необходимо каким-то образом узнать, что были перебраны все элементы.</p>

<p>Генератор &ndash; это специальная функция, которая сохраняет внутреннее состояние и способна приостановить свое выполнение. Когда функция будет вызвана в следующий раз, то она продолжит выполнение на том месте, где остановилась, вместо того чтобы отработать заново. Это достигается вызовом специального оператора yield, который возвращает значение (аналогично оператору return) и приостанавливает функцию до ее следующего вызова.</p>

<p>Пример генератора на Python:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">counter</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="k">yield</span> <span class="n">n</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>В примере реализован счетчик, который сгенерирует новое значение каждый раз, когда будет вызван. Поскольку в цикле отсутствует условие выхода из цикла, счетчик по сути генерирует бесконечную последовательность целых чисел.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">counter</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="mi">3</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<p>Как видно из примера, поведение генератора аналогично итератору.</p>

<p>Ну и наконец, потоки (данных) &ndash; своего рода &ldquo;ленивые&rdquo; списки (lazy lists). Это означает, что элементы коллекции вычисляются &ldquo;по требованию&rdquo;, всякий раз при попытке доступа к ним. Собственно, потоки &ndash; это абстракция, структура данных с определенными свойствами. Реализуются они с помощью итераторов и генераторов. Так как элементы вычисляются тогда, когда к ним пытаются получить доступ, потоки могут быть бесконечными (как в примере счетчика).</p>

<p>В SuperCollider потоки определяются набором классов, которые наследуются от абстрактного класса <strong>Stream</strong>. Каждый поток реализует метод <strong>next</strong>, позволяющий получать последовательный доступ к элементам в потоке. Интересно то, что для абстрактного класса <strong>Object</strong> так же определен метод <strong>next</strong> (который возвращает <strong>this</strong>), а поскольку в SuperCollider все классы наследуются от <strong>Object</strong>, то любой объект по сути может быть рассмотрен как поток. Метод <strong>reset</strong>, если он реализован, сбрасывает состояние потока на начальное или просто возвращает <strong>nil</strong>.</p>

<p>Наиболее полезными классами-потомками <strong>Stream</strong> являются <strong>FuncStream</strong> и <strong>Routine</strong>. <strong>FuncStream</strong> позволяет нам использовать функции при вызове методов <strong>next</strong> и <strong>reset</strong>.</p>

<p>В следующем примере мы определяем функцию как аргумент конструктора, которая будет выполнятся всякий раз, когда мы вызываем метод <strong>next</strong>. И всякий раз эта функция будет возвращать число, выбранное из заданного списка случайным образом. Тем самым, с помощью экземпляра класса <strong>FuncStream</strong>, мы можем определить бесконечный поток, состоящий из случайных чисел.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">FuncStream</span><span class="p">.</span><span class="k">new</span><span class="p">({</span> <span class="err">#</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">choose</span> <span class="p">});</span>
</span><span class='line'><span class="mi">5</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Функция для метода <strong>reset</strong> не определена, а потому вызвав <strong>reset</strong>, мы получим <strong>nil</strong>.</p>

<p>Класс <strong>Routine</strong> также позволяет запускать функцию для определения значений в потоке данных, но особенность <strong>Routine</strong> в том, что объекты этого класса являются генераторами. То есть, с помощью <strong>yield</strong> мы сохраняем текущее состояние и приостанавливаем выполнение функции до следующего вызова метода <strong>next</strong>. Исчерпав все вызовы <strong>yield</strong>, в конечном итоге функция вернет <strong>nil</strong>. Простейшие примеры:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">Routine</span><span class="p">.</span><span class="k">new</span><span class="p">({</span> <span class="mi">1</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="mi">2</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span>  <span class="c1">// 1</span>
</span><span class='line'><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span>  <span class="c1">// 2</span>
</span><span class='line'><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span>  <span class="c1">// nil</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">Routine</span><span class="p">.</span><span class="k">new</span><span class="p">({</span>
</span><span class='line'>        <span class="mi">3</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="p">})</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="mi">4</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// выведет последовательно 0, 1, 2, nil</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>К потоку можно применять математические операции, его можно отфильтровать или применять функции к каждому элементу.</p>

<p>Метод <strong>collect</strong> &ndash; аналогичен функции map в функциональных языках программирования, а именно над каждым элементом выполняется какое-то действие, в результате мы получаем новый, уже трансформированный поток. В данном примере, к числам от 0 до 9 будет прибавлено 100:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">Routine</span><span class="p">.</span><span class="k">new</span><span class="p">({</span>
</span><span class='line'>        <span class="mi">10</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="p">})</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">collect</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">item</span><span class="p">;</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">100</span> <span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="mi">10</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Методы <strong>select</strong> и <strong>reject</strong> позволяют создать новый поток из элементов текущего, если эти элементы удовлетворяют условию (в случае <strong>select</strong>) или не удовлетворяют условию (в случае <strong>reject</strong>). Например, необходимо отобрать все нечетные числа из последовательности:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">Routine</span><span class="p">.</span><span class="k">new</span><span class="p">({</span>
</span><span class='line'>        <span class="mi">10</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="p">})</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="c1">// функция, определенная в select будет возвращать true для всех нечетных чисел</span>
</span><span class='line'><span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">select</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">item</span><span class="p">;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">odd</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="mi">5</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Аналогичную функцию, но с использованием <strong>reject</strong> можно переписать таким образом:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=</span> <span class="nx">Routine</span><span class="p">.</span><span class="k">new</span><span class="p">({</span>
</span><span class='line'>        <span class="mi">10</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="p">.</span><span class="k">yield</span><span class="p">;</span> <span class="p">})</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="c1">// функция, определенная в reject будет возвращать false для всех четных чисел</span>
</span><span class='line'><span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reject</span><span class="p">({</span> <span class="nx">arg</span> <span class="nx">item</span><span class="p">;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">even</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="mi">5</span><span class="p">.</span><span class="k">do</span><span class="p">({</span> <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">postln</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Вот, собственно, и вся базовая информация об итераторах, потоках и их реализации в SuperCollider. В следующих постах я рассмотрю события и паттерны в SuperCollider. В общем, продолжение следует.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Юнит-генераторы]]></title>
    <link href="http://ekozhura.github.io/unit-generators-part-1"/>
    <updated>2014-07-08T19:01:27+03:00</updated>
    <id>http://ekozhura.github.io/unit-generators-part-1</id>
    <content type="html"><![CDATA[<p>Пионер компьютерной музыки Макс Метьюс в своем языке MUSIC III впервые реализовал (а в последующих версиях и развил) несколько важных идей. Впоследствии, эти идеи легли в основу многих современных языков для создания компьютерной музыки.</p>

<!-- more -->


<p>Одной из таких идей является концепция юнит-генераторов, согласно которой при написании программы применяются отдельные функциональные блоки. Каждый такой блок выполняет одну конкретную задачу по генерации или обработке аудиосигналов. Комбинируя эти блоки, пользователь имеет возможность создавать достаточно сложные программы.</p>

<p>По мнению Метьюса, такой подход обеспечивал композитора гибкостью и простотой использования. С одной стороны, уже не было необходимости вручную определять значение каждого отсчета в цифровом сигнале (как бы сейчас ни смешно это звучало). С другой стороны, создание инструмента для синтеза по принципу черного ящика было слишком дорогим развлечением на то время. С юнит-генераторами композитор сам определял структуру, и он решал много или мало компонентов поместить.</p>

<p>Для обозначения юнит-генераторов Метьюс использовал наименования компонентов аналоговых синтезаторов. Так, среди юнит-генераторов есть осцилляторы (<strong>OSC</strong>), фильтры (<strong>FLT</strong>), генераторы огибающих (<strong>ENV</strong>). Но ими коллекция блоков не ограничивается &ndash; еще сумматоры (<strong>ADD2</strong>, <strong>ADD3</strong>, <strong>ADD4</strong>), мультипликаторы (<strong>MLT</strong>), блок для вывода сигналов (<strong>OUT</strong>), генераторы случайных значений (<strong>RAN</strong>, <strong>RAH</strong>).</p>

<p>Программа составляется таким образом, чтобы выходной сигнал одного юнит-генератора поступал на вход другого, и так вплоть до блока вывода. Структуру программы затем можно представить в виде блок-схемы (MUSIC V):</p>

<p><img class="left thumb" src="http://ekozhura.github.io/images/block-diagram-music-v.jpg"></p>

<p>Примеры программ на языке MUSIC V<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='fortran'><span class='line'><span class="nv">INS</span> <span class="mi">10</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="nv">OSC</span> <span class="nv">P5</span> <span class="nv">P6</span> <span class="nv">B2</span> <span class="nv">F1</span> <span class="nv">P30</span><span class="p">;</span>
</span><span class='line'><span class="nv">AD2</span> <span class="nv">P7</span> <span class="nv">V1</span> <span class="nv">B3</span><span class="p">;</span>
</span><span class='line'><span class="nv">OSC</span> <span class="nv">B2</span> <span class="nv">B3</span> <span class="nv">B2</span> <span class="nv">F2</span> <span class="nv">P29</span><span class="p">;</span>
</span><span class='line'><span class="nv">OUT</span> <span class="nv">B2</span> <span class="nv">B1</span><span class="p">;</span>
</span><span class='line'><span class="k">END</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='fortran'><span class='line'><span class="nv">INS</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="nv">OSC</span> <span class="nv">P5</span> <span class="nv">P7</span> <span class="nv">B2</span> <span class="nv">F3</span> <span class="nv">P30</span><span class="p">;</span>
</span><span class='line'><span class="nv">OSC</span> <span class="nv">P6</span> <span class="nv">P7</span> <span class="nv">B3</span> <span class="nv">F4</span> <span class="nv">P29</span><span class="p">;</span>
</span><span class='line'><span class="nv">AD2</span> <span class="nv">B2</span> <span class="nv">B3</span> <span class="nv">B2</span><span class="p">;</span>
</span><span class='line'><span class="nv">OSC</span> <span class="nv">B2</span> <span class="nv">P8</span> <span class="nv">B2</span> <span class="nv">F2</span> <span class="nv">V1</span><span class="p">;</span>
</span><span class='line'><span class="nv">OUT</span> <span class="nv">B2</span> <span class="nv">B1</span><span class="p">;</span>
</span><span class='line'><span class="k">END</span><span class="p">;</span>
</span><span class='line'><span class="nv">GEN</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mf">.999</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">511</span><span class="p">;</span>
</span><span class='line'><span class="nv">GEN</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mf">.999</span> <span class="mi">511</span><span class="p">;</span>
</span><span class='line'><span class="nv">GEN</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mf">.99</span> <span class="mi">50</span> <span class="mf">.99</span> <span class="mi">205</span> <span class="o">-</span><span class="mf">.99</span> <span class="mi">306</span> <span class="o">-</span><span class="mf">.99</span> <span class="mi">461</span> <span class="mi">0</span> <span class="mi">511</span><span class="p">;</span>
</span><span class='line'><span class="nb">NOT </span><span class="mi">0</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">2000</span> <span class="mf">.0128</span> <span class="mf">6.70</span><span class="p">;</span>
</span><span class='line'><span class="nb">NOT </span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2000</span> <span class="mi">0</span> <span class="mf">.0256</span> <span class="mf">6.70</span><span class="p">;</span>
</span><span class='line'><span class="nv">TER</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Напрашивается аналогия с модульными синтезаторами, где используется тот же прием. Более того, может показаться, что это принцип и был изначально позаимствован у первых модульных синтезаторов. Интересно то, что выпуск первых коммерческих модульных синтезаторов пришелся на тот же период, что и выход MUSIC III &ndash; это первая половина 60-ых годов. Еще один пионер компьютерной музыки, Жан Клод Риссе, который в те годы работал в Bell Labs совместно с Максом Метьюсом, утверждал что Роберт Муг (создатель одного из первых коммерческих модульных синтезаторов) был осведомлен о разработках и идеях Макса. Жан Клод и Роберт переписывались какое-то время, обсуждая друг с другом эти идеи<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Впрочем, по словам самого Макса, выход его программы опередил Роберта Муга всего на пару лет, это была своего рода логическая эволюция цифровых и аналоговых синтезаторов, идея, витавшая в воздухе и реализованная инженерами  того времени независимо друг от друга. &ldquo;В любом случае, это было огромное преимущество, потому что музыкант, который имел представление о коммутации модулей синтезаторов Муга, мог понять как соединить юнит генераторы на компьютере&rdquo;, &ndash; заметил Метьюс.</p>

<p>MUSIC V нашел свое развитие в языке Csound, где число юнит-генераторов (опкодов, в терминологии Csound) значительно возросло. Язык Max, который изначально использовался сугубо для управления внешними &ldquo;железными&rdquo; синтезаторами и DSP-процессорами, со временем эволюционировал в полноценную среду для синтеза аудио и обзавелся собственными юнит-генераторами (две наиболее популярных среды использующих язык Max &ndash; Pure Data и Max/MSP). SuperCollider и ChucK используют юнит-генераторы для обозначения и скомпилированных модулей для своих аудиодвижков, и специальных классов для работы с этими модулями.</p>

<p>NI Reaktor и AudioMulch в эту компанию не входят, так как оперируют более высокоуровневыми абстракциями (синтезаторы, семплеры, драм-машины, эффекты) и не предполагают программирования, только коммутацию модулей (впрочем, с пятой версии в Reaktor предусмотрен режим разработки на низком уровне, аналогогичный Max).</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Примеры программ и диаграмма взяты из книги M.Mathews <em>&ldquo;The Technology of Computer Music&rdquo;</em>, 1969.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Этот факт был упомянут в примечании к интервью с Максом Метьюсом для Computer Music Journal в 2008 году.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[О языках]]></title>
    <link href="http://ekozhura.github.io/about-languages"/>
    <updated>2014-07-07T18:47:51+03:00</updated>
    <id>http://ekozhura.github.io/about-languages</id>
    <content type="html"><![CDATA[<p>Несколько слов о тематике блога &ndash; о языках и средах для синтеза аудио и алгоритмической композиции. Почему они все еще актуальны, несмотря на многообразие DAW и VST плагинов, и почему стоит изучить хотя бы один из них.</p>

<!-- more -->


<p>Первые языки программирования для синтеза аудио также были первыми (и единственными) программами для создания музыки. Они разрабатывались в НИИ, выполнялись на огромных и дорогих ЭВМ. С ними работали ученые и композиторы, чья деятельность предвосхитила облик компьютерной музыки на десятилетия.</p>

<p>Но с тех пор многое изменилось. С появлением персональных компьютеров и постепенным наращиванием их мощностей, появилось разнообразное программное обеспечения для создания музыки. Стало возможным не только эмулировать реальные, &ldquo;железные&rdquo; синтезаторы, но и разрабатывать принципиально новые. Для создания партитур и ритмических рисунков уже нет необходимости использовать специальный синтаксис &ndash; им на смену пришло множество инструментов с графическим интерфейсом. Сочинение музыки на персональных компьютерах стало доступным многим, как профессиональным музыкантам и композиторам, так и любителям.</p>

<p>Сейчас нет необходимости писать программный код &ndash; современные софтверные синтезаторы обладают широкими возможностями для определения всевозможных тембров. Алгоритмическая композиция постепенно проникает в коммерческие секвенсоры.</p>

<p>И тем не менее, языки программирования и среды разработки продолжают свое существование, некоторые из них достаточно популярны. Объясняется это несколькими причинами.</p>

<p>Во-первых, низкий (относительно) порог входа. Max/MSP, Csound, SuperCollider и др. относятся к классу предменто-специфических языков (domain-specific languages), их отличие от С++ или Java &ndash; это не только специализация в конкретной предметной области. В первую очередь они обладают необходимым набором абстракций для выполнения таких задач как синтез, фильтрация или вывод сигналов. В случае языков общего назначения, придется писать программы на более низком уровне и это требует б<strong>о</strong>льших усилий и знаний. К примеру, начать работу в Max/MSP можно даже не имея предварительного опыта программирования.</p>

<p>Во-вторых, свобода действий. Работая с софтверными синтезаторами и секвенсорами мы постоянно имеем дело с ограничениями. Это вовсе не недостаток, ведь такие синтезаторы обладают достаточно внушительным функционалом. Но работая с программной средой, пользователь получает дополнительные возможности. И дело даже не в том, что мы ограничены только своим воображением. Насколько простым или насколько сложным будет такой инструмент &ndash; зависит только от нас. Свобода воли в действии.</p>

<p>В-третьих, повторное использование. Мы неограничены стандартными библиотеками сред разработки. Классы, объекты, плагины, библиотеки распространяются разработчиками специально для дальнейшего использования сообществом. Например, библиотека BBCut2 (для SuperCollider) может быть использована в вашем проекте для автоматического слайсинга ударных и алгоритмического секвенсирования. Или библиотека FTM, расширяющая Max/MSP некоторыми сложными структурами данных (матрицы, словари, кортежи).</p>

<p>В-четвертых, чаще всего это open-source проекты &ndash; распространяются бесплатно, поддерживаются многочисленным сообществом энтузиастов, с поддержкой нескольких операционных систем.</p>

<p>И наконец,  подходящий инструмент для учебных целей. Даже скоротав пару вечеров за Max/MSP или Pure Data, можно извлечь ценный опыт. Хорошее подспорье для того чтобы усвоить различные методы синтеза, разобраться в способах обработки аудио.</p>
]]></content>
  </entry>
  
</feed>
