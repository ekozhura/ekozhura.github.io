---
layout: post
title: "Композиция в SuperCollider. Часть 1. Потоки"
date: 2014-07-13 09:04:59 +0300
comments: true
categories: 
---
Основой алгоритмической композиции, по сути, являются математические методы генерации партитур. Синтаксические конструкции или библиотеки функций и классов, которые используются в композиции, часто выделяются в так называемый score language, то есть язык, который используется для определения партитур. Score language в SuperCollider базируется на потоках (абстрактный класс Stream), событиях (класс Event) и  паттернах (абстрактный класс Pattern). Сперва рассмотрим потоки.
<!--more-->
Термины **итератор**, **генератор** и **поток** в разных языках программирования используются для описания похожих концепций и абстракций, но не всегда аналогичных. В общем случае, итератор - это объект, который осуществляет последовательный доступ к элементам коллекции. Это несколько отличается от перебора элементов коллекции по их индексам. 

Интерфейс итератора предполагает следующее поведение. Во-первых, необходимо инициализировать итератор с каким-то начальным состоянием и сбрасывать состояние итератора на начальное. Начальное состояние чаще всего предполагает, что итератор вернет первый элемент коллекции. Во-вторых, необходимо извлекать следующий элемент коллекции. И наконец, если коллекция имеет конечное число элементов, необходимо каким-то образом узнать, что были перебраны все элементы.

Генератор - это специальная функция, которая сохраняет внутреннее состояние и способна приостановить свое выполнение. Когда функция будет вызвана в следующий раз, то она продолжит выполнение на том месте, где остановилась, вместо того чтобы отработать заново. Это достигается вызовом специального оператора yield, который возвращает значение (аналогично оператору return) и приостанавливает функцию до ее следующего вызова. 

Пример генератора на Python:
{% codeblock lang:python %}
def counter(n):
    while True:
        yield n
        n += 1
{% endcodeblock %}

В примере реализован счетчик, который сгенерирует новое значение каждый раз, когда будет вызван. Поскольку в цикле отсутствует условие выхода из цикла, счетчик по сути генерирует бесконечную последовательность целых чисел.

{% codeblock lang:python %}
>>> f = counter(2)
>>> f.next()
2
>>> f.next()
3
>>> f.next()
4
{% endcodeblock %}

Как видно из примера, поведение генератора аналогично итератору.

Ну и наконец, потоки (данных) - своего рода "ленивые" списки (lazy lists). Это означает, что элементы коллекции вычисляются "по требованию", всякий раз при попытке доступа к ним. Собственно, потоки - это абстракция, структура данных с определенными свойствами. Реализуются они с помощью итераторов и генераторов. Так как элементы вычисляются тогда, когда к ним пытаются получить доступ, потоки могут быть бесконечными (как в примере счетчика).

В SuperCollider потоки определяются набором классов, которые наследуются от абстрактного класса **Stream**. Каждый поток реализует метод **next**, позволяющий получать последовательный доступ к элементам в потоке. Интересно то, что для абстрактного класса **Object** так же определен метод **next** (который возвращает **this**), а поскольку в SuperCollider все классы наследуются от **Object**, то любой объект по сути может быть рассмотрен как поток. Метод **reset**, если он реализован, сбрасывает состояние потока на начальное или просто возвращает **nil**.

Наиболее полезными классами-потомками **Stream** являются **FuncStream** и **Routine**. **FuncStream** позволяет нам использовать функции при вызове методов **next** и **reset**. 

В следующем примере мы определяем функцию как аргумент конструктора, которая будет выполнятся всякий раз, когда мы вызываем метод **next**. И всякий раз эта функция будет возвращать число, выбранное из заданного списка случайным образом. Тем самым, с помощью экземпляра класса **FuncStream**, мы можем определить бесконечный поток, состоящий из случайных чисел. 

{% codeblock lang:javascript %}
(
a = FuncStream.new({ #[1, 2, 3, 4].choose });
5.do({ a.next.postln; });
)
{% endcodeblock %}

Функция для метода **reset** не определена, а потому вызвав **reset**, мы получим **nil**.

Класс **Routine** также позволяет запускать функцию для определения значений в потоке данных, но особенность **Routine** в том, что объекты этого класса являются генераторами. То есть, с помощью **yield** мы сохраняем текущее состояние и приостанавливаем выполнение функции до следующего вызова метода **next**. Исчерпав все вызовы **yield**, в конечном итоге функция вернет **nil**. Простейшие примеры: 

{% codeblock lang:javascript %}
(
a = Routine.new({ 1.yield; 2.yield; });
a.next.postln;  // 1
a.next.postln;  // 2
a.next.postln;  // nil
)
{% endcodeblock %}

{% codeblock lang:javascript %}
(
a = Routine.new({
        3.do({ arg i; i.yield; })
    });
4.do({ a.next.postln; }); // выведет последовательно 0, 1, 2, nil
)
{% endcodeblock %}

К потоку можно применять математические операции, его можно отфильтровать или применять функции к каждому элементу.

Метод **collect** - аналогичен функции map в функциональных языках программирования, а именно над каждым элементом выполняется какое-то действие, в результате мы получаем новый, уже трансформированный поток. В данном примере, к числам от 0 до 9 будет прибавлено 100:

{% codeblock lang:javascript %}
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });
b = a.collect({ arg item; item + 100 ; });
10.do({ b.next.postln; });
)
{% endcodeblock %}

Методы **select** и **reject** позволяют создать новый поток из элементов текущего, если эти элементы удовлетворяют условию (в случае **select**) или не удовлетворяют условию (в случае **reject**). Например, необходимо отобрать все нечетные числа из последовательности:

{% codeblock lang:javascript %}
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });
// функция, определенная в select будет возвращать true для всех нечетных чисел
b = a.select({ arg item; item.odd; });
5.do({ b.next.postln; });
)
{% endcodeblock %}

Аналогичную функцию, но с использованием **reject** можно переписать таким образом:

{% codeblock lang:javascript %}
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });
// функция, определенная в reject будет возвращать false для всех четных чисел
b = a.reject({ arg item; item.even; });
5.do({ b.next.postln; });
)
{% endcodeblock %}

Вот, собственно, и вся базовая информация об итераторах, потоках и их реализации в SuperCollider. В следующих постах я рассмотрю события и паттерны в SuperCollider. В общем, продолжение следует.